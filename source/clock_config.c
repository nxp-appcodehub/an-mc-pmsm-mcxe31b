/*
 * Copyright 2025 NXP
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
/***********************************************************************************************************************
 * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
 * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
 **********************************************************************************************************************/
/*
 * How to set up clock using clock driver functions:
 *
 * 1. Setup clock sources.
 *
 * 2. Set up all selectors to provide selected clocks.
 *
 * 3. Set up all dividers.
 */

/* clang-format off */
/* TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
!!GlobalInfo
product: Clocks v17.0
processor: MCXE31B
package_id: MCXE31BMPB
mcu_data: ksdk2_0
processor_version: 0.2506.30
 * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS **********/
/* clang-format on */

#include "fsl_clock.h"
#include "clock_config.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/

/*******************************************************************************
 ************************ BOARD_InitBootClocks function ************************
 ******************************************************************************/
void BOARD_InitBootClocks(void)
{
    BOARD_BootClockRUN();
}

/* clang-format off */
/* TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
!!Configuration
name: BOARD_BootClockRUN
called_from_default_init: true
outputs:
- {id: AIPS_PLAT_CLK.outFreq, value: 40 MHz}
- {id: AIPS_SLOW_CLK.outFreq, value: 40 MHz}
- {id: CLKOUT_STANDBY.outFreq, value: 24 MHz}
- {id: CORE_CLK.outFreq, value: 160 MHz}
- {id: DCM_CLK.outFreq, value: 32 MHz}
- {id: EMAC_RX_CLK.outFreq, value: 48 MHz}
- {id: EMAC_TS_CLK.outFreq, value: 48 MHz}
- {id: EMAC_TX_CLK.outFreq, value: 48 MHz}
- {id: FIRC_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN0_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN1_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN2_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN3_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN4_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN5_PE_CLK.outFreq, value: 48 MHz}
- {id: FXOSC_CLK.outFreq, value: 16 MHz}
- {id: HSE_CLK.outFreq, value: 80 MHz}
- {id: LBIST_CLK.outFreq, value: 40 MHz}
- {id: PLL_PHI0_CLK.outFreq, value: 160 MHz}
- {id: PLL_PHI1_CLK.outFreq, value: 160 MHz}
- {id: QSPI_2xSFCK.outFreq, value: 48 MHz}
- {id: QSPI_MEM_CLK.outFreq, value: 160 MHz}
- {id: QSPI_SFCK.outFreq, value: 24 MHz}
- {id: SIRC_CLK.outFreq, value: 32 kHz}
- {id: STM0_CLK.outFreq, value: 48 MHz}
- {id: STM1_CLK.outFreq, value: 48 MHz}
- {id: TRACE_CLK.outFreq, value: 48 MHz}
settings:
- {id: CORE_PLLODIV_0_DE, value: Enabled}
- {id: CORE_PLLODIV_1_DE, value: Enabled}
- {id: CORE_PLL_PD, value: Power_up}
- {id: FXOSC_PM, value: Crystal_mode}
- {id: MC_CGM.MUX_0_CSC.sel, value: PLL.PLL_PHI0_CLK}
- {id: MC_CGM.MUX_0_DC_1.scale, value: '4', locked: true}
- {id: MC_CGM.MUX_0_DC_2.scale, value: '4', locked: true}
- {id: MC_CGM.MUX_0_DC_3.scale, value: '2', locked: true}
- {id: MC_CGM.MUX_0_DC_4.scale, value: '5'}
- {id: PLL.CORE_MFD.scale, value: '120', locked: true}
- {id: PLL.ODIV2.scale, value: '2', locked: true}
- {id: PLL.PLLODIV_0.scale, value: '3', locked: true}
- {id: PLL.PLLODIV_1.scale, value: '3', locked: true}
- {id: PLL.PLL_PREDIV.scale, value: '2', locked: true}
sources:
- {id: FXOSC.FXOSC.outFreq, value: 16 MHz, enabled: true}
 * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS **********/
/* clang-format on */

const fxosc_config_t g_fxoscConfig_BOARD_BootClockRUN =
    {
        .freqHz = 16000000,                       /* FXOSC output clock frequency: 16000000Hz */
        .workMode = kFXOSC_ModeCrystal,           /* Crystal mode */
        .startupDelay = 49,                       /* FXOSC startup delay: 49counts */
        .overdriveProtect = 12                    /* FXOSC overdrive protection: 12 */
    };
const pll_config_t g_pllConfig_BOARD_BootClockRUN =
    {
        .workMode = kPLL_ModeInteger,             /* PLL operates in integer-only mode */
        .preDiv = 2,                              /* PLL input clock predivider: 2 */
        .postDiv = 2,                             /* PLL output clock divider: 2 */
        .multiplier = 120,                        /* PLL output clock divider: 120 */
        .fracLoopDiv = 0,                         /* PLL fractional loop numerator: 0 */
        .stepSize = 0,                            /* SSCG mode frequency modulation step size: 0 */
        .stepNum = 0,                             /* SSCG mode number of steps of modulation period: 0 */
        .accuracy = kPLL_UnlockAccuracy9,         /* Unlock range = Expected value deviates by 9 (recommended when PLLFM[SSCGBYP] = 1). */
        .outDiv = {3, 3}                          /* PLL Output Divider: 3, 3*/
    };
const clock_pcfs_config_t g_pcfsConfig_BOARD_BootClockRUN =
    {
        .maxAllowableIDDchange = 50,              /* Maximum variation of current per time: 50 mA/microsec */
        .stepDuration = 1,                        /* Step duration of each PCFS step: 1 us/step */
        .clkSrcFreq = 160000000                   /* Frequency of the clock source from which ramp-down and to which ramp-up are processed: 160000000 Hz */
    };
/*******************************************************************************
 * Code for BOARD_BootClockRUN configuration
 ******************************************************************************/
void BOARD_BootClockRUN_InitClockModule(clock_module_t module)
{
    switch(module) {
        case kClockModule_FIRC:
            /* Switch the FIRC_DIV_SEL to the desired diveder. */
            CLOCK_SetFircDiv(kFIRC_Undivided);
            /* Disable FIRC in standby mode. */
            CLOCK_DisableFircInStandbyMode();
            break;
        case kClockModule_SIRC:
            /* Disable SIRC in standby mode. */
            CLOCK_DisableSircInStandbyMode();
            break;
        case kClockModule_SXOSC:
            /* Disable SXOSC. */
            CLOCK_InitSxosc(false, 125U);
            break;
        case kClockModule_FXOSC:
            /* Enable FXOSC. */
            CLOCK_InitFxosc(&g_fxoscConfig_BOARD_BootClockRUN);
            break;
        case kClockModule_PLL:
            /* Enable PLL. */
            CLOCK_InitPll(&g_pllConfig_BOARD_BootClockRUN);
            break;
        case kClockModule_MUX0_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_MUX0);
            /* Configure MUX_0_CSC dividers */
            CLOCK_SetClkMux0DivTriggerType(KCLOCK_ImmediateUpdate);
            CLOCK_SetClkDiv(kCLOCK_DivCoreClk, 1U);
            CLOCK_SetClkDiv(kCLOCK_DivAipsPlatClk, 4U);
            CLOCK_SetClkDiv(kCLOCK_DivAipsSlowClk, 4U);
            CLOCK_SetClkDiv(kCLOCK_DivHseClk, 2U);
            CLOCK_SetClkDiv(kCLOCK_DivDcmClk, 5U);
            CLOCK_SetClkDiv(kCLOCK_DivLbistClk, 4U);
            CLOCK_SetClkDiv(kCLOCK_DivQspiClk, 1U);
            CLOCK_ProgressiveClockFrequencySwitch(kPLL_PHI0_CLK_to_MUX0, &g_pcfsConfig_BOARD_BootClockRUN);
            break;
        case kClockModule_MUX1_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_STM0);
            /* Configure MUX_1_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivStm0Clk, 1U);
            break;
        case kClockModule_MUX2_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_STM1);
            /* Configure MUX_2_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivStm1Clk, 1U);
            break;
        case kClockModule_MUX3_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_FLEXCAN012_PE);
            /* Configure MUX_3_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivFlexcan012PeClk, 1U);
            break;
        case kClockModule_MUX4_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_FLEXCAN345_PE);
            /* Configure MUX_4_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivFlexcan345PeClk, 1U);
            break;
        case kClockModule_MUX5_CSC_DC:
            /* Configure MUX_5_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivClkoutStandbyClk, 2U);
            /* Configure MUX_5_CSC selector */
            CLOCK_AttachClk(kFIRC_CLK_to_CLKOUT_STANDBY);
            break;
        case kClockModule_MUX6_CSC_DC:
            /* Configure MUX_6_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivClkoutRunClk, 0U);
            /* Configure MUX_6_CSC selector */
            CLOCK_AttachClk(kFIRC_CLK_to_CLKOUT_RUN);
            break;
        case kClockModule_MUX7_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_EMAC_RX);
            /* Configure MUX_7_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivEmacRxClk, 1U);
            break;
        case kClockModule_MUX8_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_EMAC_TX);
            /* Configure MUX_8_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivEmacTxClk, 1U);
            break;
        case kClockModule_MUX9_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_EMAC_TS);
            /* Configure MUX_9_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivEmacTsClk, 1U);
            break;
        case kClockModule_MUX10_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_QSPI_SFCK);
            /* Configure MUX_10_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivQspiSfckClk, 1U);
            break;
        case kClockModule_MUX11_CSC_DC:
            /* Configure MUX_11_CSC divider */
            CLOCK_SetClkDiv(kCLOCK_DivTraceClk, 1U);
            /* Configure MUX_11_CSC selector */
            CLOCK_AttachClk(kFIRC_CLK_to_TRACE);
            break;
        case kClockModule_JTAG_TCK:
            /* JTAG TCK does not requiere any initialization in clock script. */
            break;
        default:
            assert(false);
            break;
    }
}

void BOARD_BootClockRUN(void)
{
    BOARD_BootClockRUN_InitClockModule(kClockModule_FIRC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_SIRC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_FXOSC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_JTAG_TCK);
    BOARD_BootClockRUN_InitClockModule(kClockModule_PLL);
    BOARD_BootClockRUN_InitClockModule(kClockModule_SXOSC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX0_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX1_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX2_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX3_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX4_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX5_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX6_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX7_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX8_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX9_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX10_CSC_DC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX11_CSC_DC);
    /*!< Set SystemCoreClock variable. */
    SystemCoreClockUpdate();
}

